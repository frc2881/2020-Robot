// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import java.util.function.DoubleSupplier;

import com.revrobotics.CANEncoder;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.filters.LinearDigitalFilter;
import edu.wpi.first.wpilibj.smartdashboard.SendableBuilder;
import frc.robot.Utils.DistancePerPulse;
import frc.robot.Utils.frc4048.Logging;
import frc.robot.commands.DriveWithJoysticks;
import frc.robot.commands.NavX;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.SPI;


/**
 *
 */
public class Drive extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
    private static final double straightKc = 1.9;
    private static final double straightPc = 1.271679;  // period of oscillation
    private static final double straightP = 0.6 * straightKc;
    private static final double straightI = 0;//2 * straightP * 0.05 / straightPc;
    private static final double straightD = 0.125 * straightP * straightPc / 0.05;
    private static final double straightF = 0.00;


    private static final double highestGearTeethNumber = 50;
    private static final double lowestGearTeethNumber = 12;
    private static final double encoderCountsPerRevolution = 42;
    private static final double wheelDiameter = 6;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private CANSparkMax leftFront;
private CANSparkMax leftRear;
private SpeedControllerGroup left;
private CANSparkMax rightFront;
private CANSparkMax rightRear;
private SpeedControllerGroup right;
private DifferentialDrive differentialDrive1;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private final PowerDistributionPanel pdp = new PowerDistributionPanel(10);
private CANEncoder leftEncoder;
private CANEncoder rightEncoder;
private DoubleSupplier leftEncoderPosition;
private DoubleSupplier rightEncoderPosition;
private double beginningPosition;
private PIDController straightPID;
private double straightSpeed;
private PIDController turnPID;
private double rotateToAngleRate;
private double x, y, d, a;
private double maxCurrent;
private final LinearDigitalFilter currentMovingAverage;
private final LinearDigitalFilter straightMovingAverage;
private final LinearDigitalFilter turnMovingAverage;


private static final double turnKc = 0.0475;
private static final double turnPc = 1.273;
private static final double turnP = .6 * turnKc;
private static final double turnI = 0;  //2*turnP/turnTu;
private static final double turnD = 0.125 * turnP * turnPc / 0.05;
private static final double turnF = 0.00;
public NavX navX;



    public Drive() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
leftFront = new CANSparkMax(1, MotorType.kBrushless);

leftFront.restoreFactoryDefaults();  
leftFront.setInverted(false);
leftFront.setIdleMode(IdleMode.kCoast);
  
        
leftRear = new CANSparkMax(2, MotorType.kBrushless);

leftRear.restoreFactoryDefaults();  
leftRear.setInverted(false);
leftRear.setIdleMode(IdleMode.kCoast);
  
        


//Set SlaveSpeedControllers to Follow MasterSpeedController
leftRear.follow(leftFront);
        
        
        
rightFront = new CANSparkMax(3, MotorType.kBrushless);

rightFront.restoreFactoryDefaults();  
rightFront.setInverted(false);
rightFront.setIdleMode(IdleMode.kCoast);
  
        
rightRear = new CANSparkMax(4, MotorType.kBrushless);

rightRear.restoreFactoryDefaults();  
rightRear.setInverted(false);
rightRear.setIdleMode(IdleMode.kCoast);
  
        


//Set SlaveSpeedControllers to Follow MasterSpeedController
rightRear.follow(rightFront);
        
        
        
differentialDrive1 = new DifferentialDrive(leftFront, rightFront);
addChild("Differential Drive 1",differentialDrive1);
differentialDrive1.setSafetyEnabled(true);
differentialDrive1.setExpiration(0.1);
differentialDrive1.setMaxOutput(1.0);        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    navX = new NavX(SPI.Port.kMXP);
        addChild("NavX",navX);
    turnPID = new PIDController(turnP, turnI, turnD, turnF, navX, new PIDOutput() {
        @Override
        public void pidWrite(double output) {
            rotateToAngleRate = output;
        }
    });
    addChild("TurnPID", turnPID);

    turnPID.setInputRange(-180, 180);
        turnPID.setOutputRange(-1, 1);
        turnPID.setAbsoluteTolerance(5);
        turnPID.setContinuous(true);
        turnPID.disable();
        /* Add the PID Controller to the Test-mode dashboard, allowing manual  */
        /* tuning of the Turn Controller's P, I and D coefficients.            */
        /* Typically, only the P value needs to be modified.                   */
        turnPID.setName("DriveSubsystem", "RotateController");
        turnMovingAverage = LinearDigitalFilter.movingAverage(navX, 3);


double distancePerPulse = DistancePerPulse.get(highestGearTeethNumber, lowestGearTeethNumber, encoderCountsPerRevolution, wheelDiameter);
leftEncoder= leftRear.getEncoder();
leftEncoderPosition = () -> leftEncoder.getPosition() * distancePerPulse;

rightEncoder= rightRear.getEncoder();
rightEncoderPosition = () -> rightEncoder.getPosition() * distancePerPulse;

beginningPosition= ((leftEncoder.getPosition()+rightEncoder.getPosition())/2) * distancePerPulse;

straightPID = new PIDController(straightP, straightI, straightD, new DistancePIDSource(), new PIDOutput() {
    @Override
    public void pidWrite(double output) {
        straightSpeed = output;
    }
});
addChild("StraightPID", straightPID);



    }

    @Override
    public void initSendable(SendableBuilder builder) {
        super.initSendable(builder);
        builder.addDoubleProperty("MaxCurrent", () -> maxCurrent, null);
        builder.addStringProperty("Location", this::getLocation, null);
        builder.addDoubleProperty("X", () -> x, null);
        builder.addDoubleProperty("Y", () -> y, null);
    }

    public String getLocation() {
        return String.format("(%.2f,%.2f) %.1fÂ°", x, y, a);
    }

    public void reset() {
        straightPID.reset();
        turnPID.reset();
        navX.reset();  // WaitUntilNavXCalibrated will wait until the navX is ready to use again
        maxCurrent = 0;
        x = y = d = a = 0;
    }
    
    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new DriveWithJoysticks());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop
        double current = pdp.getTotalCurrent();
        if (maxCurrent < current) {
            maxCurrent = current;
        }

        double distance = getDistanceDriven();
        double angle = navX.getAngle();  // not constrained to -180 to 180

        double change = distance - d;
        double midAngle = (a + angle) / 2.0;  // half way between previous angle and new angle
        double radians = midAngle * Math.PI / 180;
        x += change * Math.sin(radians);
        y += change * Math.cos(radians);
        d = distance;
        a = angle;
    }

    public boolean isNavXReady(){
        return !navX.isConnected() || !navX.isCalibrating();
    }
    public double getRotateToAngleRate() {
        return rotateToAngleRate;
    }

    public void initializeTurnToHeading(double angle) {
        //depending on whether we need to turn or not, one or the other would be used
        turnPID.setSetpoint(angle);
        rotateToAngleRate = 0;
        turnPID.enable();
    }

    public void changeHeadingTurnToHeading(double angle) {
        //update the setPoint of the PID loop if the driver has changed the controller value before the turn was finished
        turnPID.setSetpoint(angle);
    }

    public double getTurnToHeadingError() {
        return turnPID.getError();
    }

    public boolean isFinishedTurnToHeading() {
        //called to finish the command when PID loop is finished
        boolean stopped = Math.abs(navX.pidGet() - turnMovingAverage.pidGet()) < 0.1;
        return stopped && turnPID.onTarget();
    }

    public boolean isFinishedDriveForward() {
        //called to finish the command when PID loop is finished
        boolean stopped = Math.abs(getDistanceDriven() - straightMovingAverage.pidGet()) < 0.02;
        boolean pushing = (currentMovingAverage.pidGet() > 60 && Math.abs(getAverageEncoderSpeed()) < 1);
        if (pushing){
            Robot.log("Drive Forward interrupted");
        };
        if (stopped && straightPID.onTarget() || pushing ) {
            return true;
        }
        return false;
    }

    public void endTurnToHeading() {
        //Disable the PID loop when the turn is finished
        turnPID.disable();
    }

    public void autonomousRotate(double leftSpeed, double rightSpeed) {
        // DONT Use 'squaredInputs' or deadband in autonomous
        differentialDrive1.setDeadband(0);
        differentialDrive1.tankDrive(leftSpeed, rightSpeed, false);
    }
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    public void tankDrive(double leftSpeed, double rightSpeed) {
        
        // if(intakeLocation == IntakeLocation.FRONT) {
        //     differentialDrive.tankDrive(leftSpeed, rightSpeed, true);
        // }
        // else {
        //     differentialDrive.tankDrive(-rightSpeed, -leftSpeed, true);
        // }
        differentialDrive1.tankDrive(leftSpeed, rightSpeed, true);
        System.out.println("tankDrive");
    }

    public final Logging.LoggingContext loggingContext = new Logging.LoggingContext(Logging.Subsystems.DRIVE) {

		@Override
		protected void addAll() {
            add("Drive Position", getDriveEncoderDistance());
		}
    	
    };

    public double getDriveEncoderDistance(){
        return (leftEncoderPosition.getAsDouble() + rightEncoderPosition.getAsDouble())/2;
    }

    public void setDriveSpeed(double speed)
    {
        if (speed > 1) {
            speed=1;
        }

        if (speed < -1) {
            speed = -1;
        }

        if((speed > 0) && (speed <= 0.1)) {
            speed = 0.1;
        }

        if ((speed < 0) && (speed > -0.1)) {
            speed = -0.1;
        }

        differentialDrive1.tankDrive(speed, speed);
    }

    private double getDistanceDriven() {
        double left = leftEncoderPosition.getAsDouble();
        double right = rightEncoderPosition.getAsDouble();
        return (left + right) / 2;
    }

    private class DistancePIDSource implements PIDSource {
        @Override
        public void setPIDSourceType(PIDSourceType pidSource) {
        }

        @Override
        public PIDSourceType getPIDSourceType() {
            return PIDSourceType.kDisplacement;
        }

        @Override
        public double pidGet() {
            return getDistanceDriven();
        }
    }

    public void endDriveForward() {
        //Disable the PID loop when the turn is finished
        straightPID.disable();
        turnPID.disable();
    }
}

