// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import java.util.function.DoubleSupplier;

import com.revrobotics.CANEncoder;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
<<<<<<< HEAD
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.PIDSourceType;
=======
>>>>>>> origin/Helena
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import frc.robot.Utils.DistancePerPulse;
import frc.robot.Utils.frc4048.Logging;
import frc.robot.commands.DriveWithJoysticks;
import frc.robot.commands.NavX;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.SPI;


/**
 *
 */
public class Drive extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
    private static final double straightKc = 1.9;
    private static final double straightPc = 1.271679;  // period of oscillation
    private static final double straightP = 0.6 * straightKc;
    private static final double straightI = 0;//2 * straightP * 0.05 / straightPc;
    private static final double straightD = 0.125 * straightP * straightPc / 0.05;
    private static final double straightF = 0.00;


    private static final double highestGearTeethNumber = 50;
    private static final double lowestGearTeethNumber = 12;
    private static final double encoderCountsPerRevolution = 42;
    private static final double wheelDiameter = 6;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private CANSparkMax leftFront;
private CANSparkMax leftRear;
private SpeedControllerGroup left;
private CANSparkMax rightFront;
private CANSparkMax rightRear;
private SpeedControllerGroup right;
private DifferentialDrive differentialDrive1;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private static final double turnKc = 0.0475;
    private static final double turnPc = 1.273;
    private static final double turnP = .6 * turnKc;
    private static final double turnI = 0;  //2*turnP/turnTu;
    private static final double turnD = 0.125 * turnP * turnPc / 0.05;
    private static final double turnF = 0.00;
    public NavX navX;


    private PIDController turnPID;

private CANEncoder leftEncoder;
private CANEncoder rightEncoder;
private DoubleSupplier leftEncoderPosition;
private DoubleSupplier rightEncoderPosition;
private double beginningPosition;
<<<<<<< HEAD
private PIDController straightPID;
    private double straightSpeed;
=======
private double rotateToAngleRate;
>>>>>>> origin/Helena


    public Drive() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
leftFront = new CANSparkMax(1, MotorType.kBrushless);

leftFront.restoreFactoryDefaults();  
leftFront.setInverted(false);
leftFront.setIdleMode(IdleMode.kCoast);
  
        
leftRear = new CANSparkMax(2, MotorType.kBrushless);

leftRear.restoreFactoryDefaults();  
leftRear.setInverted(false);
leftRear.setIdleMode(IdleMode.kCoast);
  
        


//Set SlaveSpeedControllers to Follow MasterSpeedController
leftRear.follow(leftFront);
        
        
        
rightFront = new CANSparkMax(3, MotorType.kBrushless);

rightFront.restoreFactoryDefaults();  
rightFront.setInverted(false);
rightFront.setIdleMode(IdleMode.kCoast);
  
        
rightRear = new CANSparkMax(4, MotorType.kBrushless);

rightRear.restoreFactoryDefaults();  
rightRear.setInverted(false);
rightRear.setIdleMode(IdleMode.kCoast);
  
        


//Set SlaveSpeedControllers to Follow MasterSpeedController
rightRear.follow(rightFront);
        
        
        
differentialDrive1 = new DifferentialDrive(leftFront, rightFront);
addChild("Differential Drive 1",differentialDrive1);
differentialDrive1.setSafetyEnabled(true);
differentialDrive1.setExpiration(0.1);
differentialDrive1.setMaxOutput(1.0);

<<<<<<< HEAD
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
=======
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    navX = new NavX(SPI.Port.kMXP);
        addChild("NavX",navX);
    turnPID = new PIDController(turnP, turnI, turnD, turnF, navX, new PIDOutput() {
        @Override
        public void pidWrite(double output) {
            rotateToAngleRate = output;
        }
    });
    addChild("TurnPID", turnPID);
>>>>>>> origin/Helena
double distancePerPulse = DistancePerPulse.get(highestGearTeethNumber, lowestGearTeethNumber, encoderCountsPerRevolution, wheelDiameter);
leftEncoder= leftRear.getEncoder();
leftEncoderPosition = () -> leftEncoder.getPosition() * distancePerPulse;

rightEncoder= rightRear.getEncoder();
rightEncoderPosition = () -> rightEncoder.getPosition() * distancePerPulse;

beginningPosition= ((leftEncoder.getPosition()+rightEncoder.getPosition())/2) * distancePerPulse;

straightPID = new PIDController(straightP, straightI, straightD, new DistancePIDSource(), new PIDOutput() {
    @Override
    public void pidWrite(double output) {
        straightSpeed = output;
    }
});
addChild("StraightPID", straightPID);



    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new DriveWithJoysticks());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

    }

    public boolean isNavXReady(){
        return !navX.isConnected() || !navX.isCalibrating();
    }
    public double getRotateToAngleRate() {
        return rotateToAngleRate;
    }
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    public void tankDrive(double leftSpeed, double rightSpeed) {
        
        // if(intakeLocation == IntakeLocation.FRONT) {
        //     differentialDrive.tankDrive(leftSpeed, rightSpeed, true);
        // }
        // else {
        //     differentialDrive.tankDrive(-rightSpeed, -leftSpeed, true);
        // }
        differentialDrive1.tankDrive(leftSpeed, rightSpeed, true);
        System.out.println("tankDrive");
    }

    public final Logging.LoggingContext loggingContext = new Logging.LoggingContext(Logging.Subsystems.DRIVE) {

		@Override
		protected void addAll() {
            add("Drive Position", getDriveEncoderDistance());
		}
    	
    };

    public double getDriveEncoderDistance(){
        return (leftEncoderPosition.getAsDouble() + rightEncoderPosition.getAsDouble())/2;
    }

    public void setDriveSpeed(double speed)
    {
        if (speed > 1) {
            speed=1;
        }

        if (speed < -1) {
            speed = -1;
        }

        if((speed > 0) && (speed <= 0.1)) {
            speed = 0.1;
        }

        if ((speed < 0) && (speed > -0.1)) {
            speed = -0.1;
        }

        differentialDrive1.tankDrive(speed, speed);
    }

    private double getDistanceDriven() {
        double left = leftEncoderPosition.getAsDouble();
        double right = rightEncoderPosition.getAsDouble();
        return (left + right) / 2;
    }

    private class DistancePIDSource implements PIDSource {
        @Override
        public void setPIDSourceType(PIDSourceType pidSource) {
        }

        @Override
        public PIDSourceType getPIDSourceType() {
            return PIDSourceType.kDisplacement;
        }

        @Override
        public double pidGet() {
            return getDistanceDriven();
        }
    }

    public void endDriveForward() {
        //Disable the PID loop when the turn is finished
        straightPID.disable();
        turnPID.disable();
    }
}

