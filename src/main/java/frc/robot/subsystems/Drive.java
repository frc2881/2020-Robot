// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import java.util.function.DoubleSupplier;

import com.revrobotics.CANEncoder;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;

import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.filters.LinearDigitalFilter;
import frc.robot.Utils.DistancePerPulse;
import frc.robot.Utils.frc4048.Logging;
import frc.robot.commands.DriveWithJoysticks;
import frc.robot.commands.NavX;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.SPI;


/**
 *
 */
public class Drive extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
    static final double highestGearTeethNumber = 1;
    static final double lowestGearTeethNumber = 8.33; 
    static final double encoderCountsPerRevolution = 42;
    static final double wheelDiameter = 6;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private CANSparkMax leftFront;
private CANSparkMax leftRear;
private SpeedControllerGroup left;
private CANSparkMax rightFront;
private CANSparkMax rightRear;
private SpeedControllerGroup right;
private DifferentialDrive differentialDrive1;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private static final double turnKc = 0.0475;
    private static final double turnPc = 1.273;
    private static final double turnP = .6 * turnKc;
    private static final double turnI = 0;  //2*turnP/turnTu;
    private static final double turnD = 0.125 * turnP * turnPc / 0.05;
    private static final double turnF = 0.00;
    public NavX navX;
    private final LinearDigitalFilter turnMovingAverage;



    private PIDController turnPID;

private CANEncoder leftEncoder;
private CANEncoder rightEncoder;
private DoubleSupplier leftEncoderPosition;
private DoubleSupplier rightEncoderPosition;
private double beginningPosition;
private double rotateToAngleRate;


    public Drive() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
leftFront = new CANSparkMax(1, MotorType.kBrushless);

leftFront.restoreFactoryDefaults();  
leftFront.setInverted(false);
leftFront.setIdleMode(IdleMode.kCoast);
  
        
leftRear = new CANSparkMax(2, MotorType.kBrushless);

leftRear.restoreFactoryDefaults();  
leftRear.setInverted(false);
leftRear.setIdleMode(IdleMode.kCoast);
  
        


//Set SlaveSpeedControllers to Follow MasterSpeedController
leftRear.follow(leftFront);
        
        
        
rightFront = new CANSparkMax(3, MotorType.kBrushless);

rightFront.restoreFactoryDefaults();  
rightFront.setInverted(false);
rightFront.setIdleMode(IdleMode.kCoast);
  
        
rightRear = new CANSparkMax(4, MotorType.kBrushless);

rightRear.restoreFactoryDefaults();  
rightRear.setInverted(false);
rightRear.setIdleMode(IdleMode.kCoast);
  
        


//Set SlaveSpeedControllers to Follow MasterSpeedController
rightRear.follow(rightFront);
        
        
        
differentialDrive1 = new DifferentialDrive(leftFront, rightFront);
addChild("Differential Drive 1",differentialDrive1);
differentialDrive1.setSafetyEnabled(true);
differentialDrive1.setExpiration(0.1);
differentialDrive1.setMaxOutput(1.0);

        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    navX = new NavX(SPI.Port.kMXP);
        addChild("NavX",navX);
    turnPID = new PIDController(turnP, turnI, turnD, turnF, navX, new PIDOutput() {
        @Override
        public void pidWrite(double output) {
            rotateToAngleRate = output;
        }
    });
    addChild("TurnPID", turnPID);

    turnPID.setInputRange(-180, 180);
        turnPID.setOutputRange(-1, 1);
        turnPID.setAbsoluteTolerance(5);
        turnPID.setContinuous(true);
        turnPID.disable();
        /* Add the PID Controller to the Test-mode dashboard, allowing manual  */
        /* tuning of the Turn Controller's P, I and D coefficients.            */
        /* Typically, only the P value needs to be modified.                   */
        turnPID.setName("DriveSubsystem", "RotateController");
        turnMovingAverage = LinearDigitalFilter.movingAverage(navX, 3);


double distancePerPulse = DistancePerPulse.get(highestGearTeethNumber, lowestGearTeethNumber, encoderCountsPerRevolution, wheelDiameter);
leftEncoder= leftRear.getEncoder();
leftEncoderPosition = () -> {return(leftEncoder.getPosition() * -distancePerPulse);};

rightEncoder= rightRear.getEncoder();
rightEncoderPosition = () -> {return(rightEncoder.getPosition() * -distancePerPulse);};

beginningPosition= ((leftEncoder.getPosition()+rightEncoder.getPosition())/2) * distancePerPulse;

    }

    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new DriveWithJoysticks());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

    }

    public boolean isNavXReady(){
        return !navX.isConnected() || !navX.isCalibrating();
    }
    public double getRotateToAngleRate() {
        return rotateToAngleRate;
    }

    public void initializeTurnToHeading(double angle) {
        //depending on whether we need to turn or not, one or the other would be used
        turnPID.setSetpoint(angle);
        rotateToAngleRate = 0;
        turnPID.enable();
    }

    public void changeHeadingTurnToHeading(double angle) {
        //update the setPoint of the PID loop if the driver has changed the controller value before the turn was finished
        turnPID.setSetpoint(angle);
    }

    public double getTurnToHeadingError() {
        return turnPID.getError();
    }

    public boolean isFinishedTurnToHeading() {
        //called to finish the command when PID loop is finished
        boolean stopped = Math.abs(navX.pidGet() - turnMovingAverage.pidGet()) < 0.1;
        return stopped && turnPID.onTarget();
    }

    public void endTurnToHeading() {
        //Disable the PID loop when the turn is finished
        turnPID.disable();
    }

    public void autonomousRotate(double leftSpeed, double rightSpeed) {
        // DONT Use 'squaredInputs' or deadband in autonomous
        differentialDrive1.setDeadband(0);
        differentialDrive1.tankDrive(leftSpeed, rightSpeed, false);
    }
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    
    public void tankDrive(double leftSpeed, double rightSpeed) {
        
        // if(intakeLocation == IntakeLocation.FRONT) {
        //     differentialDrive.tankDrive(leftSpeed, rightSpeed, true);
        // }
        // else {
        //     differentialDrive.tankDrive(-rightSpeed, -leftSpeed, true);
        // }
        differentialDrive1.tankDrive(leftSpeed, rightSpeed, true);
        //System.out.println("tankDrive");
    }

    public final Logging.LoggingContext loggingContext = new Logging.LoggingContext(Logging.Subsystems.DRIVE) {

		@Override
		protected void addAll() {
            add("Drive Position", getDriveEncoderDistance());
		}
    	
    };

    public double getDriveEncoderDistance(){
        return (leftEncoderPosition.getAsDouble() + rightEncoderPosition.getAsDouble())/2;
    }

    public void setDriveSpeed(double speed)
    {
        if (speed > .3) {
            speed=.3;
        }

        if (speed < -.3) {
            speed = -.3;
        }

        if((speed > 0) && (speed <= 0.2)) {
            speed = 0.2;
        }

        if ((speed < 0) && (speed > -0.2)) {
            speed = -0.2;
        }

        differentialDrive1.tankDrive(speed, speed);
    }



}

